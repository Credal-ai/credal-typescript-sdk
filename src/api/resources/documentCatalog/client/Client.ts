/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from "../../../../environments.js";
import * as core from "../../../../core/index.js";
import * as Credal from "../../../index.js";
import { mergeHeaders, mergeOnlyDefinedHeaders } from "../../../../core/headers.js";
import * as errors from "../../../../errors/index.js";

export declare namespace DocumentCatalog {
    export interface Options {
        environment?: core.Supplier<environments.CredalEnvironment | string>;
        /** Specify a custom URL to connect the client to. */
        baseUrl?: core.Supplier<string>;
        apiKey?: core.Supplier<core.BearerToken | undefined>;
        /** Additional headers to include in requests. */
        headers?: Record<string, string | core.Supplier<string | undefined> | undefined>;
        fetcher?: core.FetchFunction;
    }

    export interface RequestOptions {
        /** The maximum time to wait for a response in seconds. */
        timeoutInSeconds?: number;
        /** The number of times to retry the request. Defaults to 2. */
        maxRetries?: number;
        /** A hook to abort the request. */
        abortSignal?: AbortSignal;
        /** Additional query string parameters to include in the request. */
        queryParams?: Record<string, unknown>;
        /** Additional headers to include in the request. */
        headers?: Record<string, string | core.Supplier<string | undefined> | undefined>;
    }
}

export class DocumentCatalog {
    protected readonly _options: DocumentCatalog.Options;

    constructor(_options: DocumentCatalog.Options = {}) {
        this._options = _options;
    }

    /**
     * @param {Credal.UploadDocumentContentsRequest} request
     * @param {DocumentCatalog.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.documentCatalog.uploadDocumentContents({
     *         documentName: "My Document",
     *         documentContents: "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.",
     *         documentExternalId: "73eead26-d124-4940-b329-5f068a0a8db9",
     *         allowedUsersEmailAddresses: ["jack@credal.ai", "ravin@credal.ai"],
     *         uploadAsUserEmail: "jack@credal.ai"
     *     })
     */
    public uploadDocumentContents(
        request: Credal.UploadDocumentContentsRequest,
        requestOptions?: DocumentCatalog.RequestOptions,
    ): core.HttpResponsePromise<Credal.UploadDocumentResponse> {
        return core.HttpResponsePromise.fromPromise(this.__uploadDocumentContents(request, requestOptions));
    }

    private async __uploadDocumentContents(
        request: Credal.UploadDocumentContentsRequest,
        requestOptions?: DocumentCatalog.RequestOptions,
    ): Promise<core.WithRawResponse<Credal.UploadDocumentResponse>> {
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.CredalEnvironment.Production,
                "/v0/catalog/uploadDocumentContents",
            ),
            method: "POST",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
                requestOptions?.headers,
            ),
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Credal.UploadDocumentResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.CredalError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.CredalError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.CredalTimeoutError(
                    "Timeout exceeded when calling POST /v0/catalog/uploadDocumentContents.",
                );
            case "unknown":
                throw new errors.CredalError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Sync a document from a source URL. Does not support recursive web search. Reach out to a Credal representative for access.
     *
     * @param {Credal.SyncSourceByUrlRequest} request
     * @param {DocumentCatalog.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.documentCatalog.syncSourceByUrl({
     *         sourceUrl: "https://drive.google.com/file/d/123456/view",
     *         uploadAsUserEmail: "ria@credal.ai"
     *     })
     */
    public syncSourceByUrl(
        request: Credal.SyncSourceByUrlRequest,
        requestOptions?: DocumentCatalog.RequestOptions,
    ): core.HttpResponsePromise<Credal.SyncSourceByUrlResponse> {
        return core.HttpResponsePromise.fromPromise(this.__syncSourceByUrl(request, requestOptions));
    }

    private async __syncSourceByUrl(
        request: Credal.SyncSourceByUrlRequest,
        requestOptions?: DocumentCatalog.RequestOptions,
    ): Promise<core.WithRawResponse<Credal.SyncSourceByUrlResponse>> {
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.CredalEnvironment.Production,
                "/v0/catalog/syncSourceByUrl",
            ),
            method: "POST",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
                requestOptions?.headers,
            ),
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Credal.SyncSourceByUrlResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.CredalError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.CredalError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.CredalTimeoutError("Timeout exceeded when calling POST /v0/catalog/syncSourceByUrl.");
            case "unknown":
                throw new errors.CredalError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Bulk patch metadata for documents, synced natively by Credal or manual API uploads
     *
     * @param {Credal.DocumentMetadataPatchRequest} request
     * @param {DocumentCatalog.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.documentCatalog.metadata({
     *         sources: [{
     *                 metadata: {
     *                     "Department": "HR",
     *                     "Country": "United States"
     *                 },
     *                 resourceIdentifier: {
     *                     type: "external-resource-id",
     *                     externalResourceId: "170NrBm0Do7gdzvr54UvyslPVWkQFOA0lgNycFmdZJQr",
     *                     resourceType: "GOOGLE_DRIVE_ITEM"
     *                 }
     *             }, {
     *                 metadata: {
     *                     "Department": "Sales",
     *                     "Vertical": "Healthcare"
     *                 },
     *                 resourceIdentifier: {
     *                     type: "external-resource-id",
     *                     externalResourceId: "123456",
     *                     resourceType: "ZENDESK_TICKET"
     *                 }
     *             }],
     *         uploadAsUserEmail: "ben@credal.ai"
     *     })
     */
    public metadata(
        request: Credal.DocumentMetadataPatchRequest,
        requestOptions?: DocumentCatalog.RequestOptions,
    ): core.HttpResponsePromise<void> {
        return core.HttpResponsePromise.fromPromise(this.__metadata(request, requestOptions));
    }

    private async __metadata(
        request: Credal.DocumentMetadataPatchRequest,
        requestOptions?: DocumentCatalog.RequestOptions,
    ): Promise<core.WithRawResponse<void>> {
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.CredalEnvironment.Production,
                "/v0/catalog/metadata",
            ),
            method: "PATCH",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
                requestOptions?.headers,
            ),
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: undefined, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.CredalError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.CredalError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.CredalTimeoutError("Timeout exceeded when calling PATCH /v0/catalog/metadata.");
            case "unknown":
                throw new errors.CredalError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    protected async _getAuthorizationHeader(): Promise<string> {
        const bearer = (await core.Supplier.get(this._options.apiKey)) ?? process?.env["CREDAL_API_KEY"];
        if (bearer == null) {
            throw new errors.CredalError({
                message:
                    "Please specify a bearer by either passing it in to the constructor or initializing a CREDAL_API_KEY environment variable",
            });
        }

        return `Bearer ${bearer}`;
    }
}
